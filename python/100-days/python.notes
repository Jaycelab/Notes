- To apply comments, the hashtag sybol is used. Any text to the right of the symbol is commented out(#)
- For bulk comments, """example text """ . (two pairs of 3 quotes on left and right)
- Python does not use curly brackets for executing expressions, instead it uses indentation 
- The first line of python code cannot have indentation
- Indentation is mandatory in python to define the blocks of statements
- The number of spaces must be uniform in a block of code
- It is preferred to use whitespaces instead of tabs to indent in python
- Nesting in Python is done by indentation after the initial block of code
- Logicaly expressions may cause issues when not comparing variables for both values. To avoid this, use the '==' operator along with the variable. E.g. if (x === 5 or x == "five") rather than if (x = 5 or "five")
- import random is used to import the random module. import time is used to import the time module
- time.sleep() is used to pause the execution of the program for a specified amount of time	in seconds
- Casting is where we explicitly tell the computer that what we are typing is a number and not a letter. This is done by using the int() function
- Twp types of integers in Python. int whole number (ex: 42) /float any number with a decimal (ex: 1.81) 
- .2f is used to specify the float value to 2 decimal places
- The input() function is used to take input from the user
- int() is used to convert the input to an integer. Passing a 2 decimal float will round the number to the nearest whole number
*Python order* 

*Tokens*
Keywords
Python keywords are special reservered words
Conveys a special meaning to the compiler/interpreter
- Identifier is used to assigna variable.
- Single quotes are usually used for single characters
- Double quotes are usually used for sentenaces
- Tripe quotes are mainly used for multilined paragraphs 
- == equality to check operands 

*Special LIterals*
- Python contains one special literal ie. **None**
- WE use it to specify to that field that is not created
- Declaration & Initialization. Both are needed; variables need to be initialized and declared.


*Operators*
- Arthimetic Operators
- Float vs division. Float gives a rounded result while division gives a decimal result




""" ********************* CLEAN UP BELOW *********************"""

Breakfast price = B
Tip = T
Tax = F

B = int("Price of meal: ")
T = int("Percentage tip: ")
F = int("Percentage of tax: ")

weight=int(input())

*Bitwise Operator*

- ^ Symbol (carrot symbol, xor)
TTF
FFF
TFT
FTT

*Negation operator*
~

*Shift Operators*
Right 

- If there are similar operators, standard right direction is used


- range()

#range(start,stop,step_size)
ange_nums=range(1,10,1)

-Step is another way of saying the increment size


*While Loop Practice*

num = int(input("Enter number"))
inc = 1

#create a temp var to hold the value to increment
while (num <= 10):
	value = num * inc
	print("The total is: ".val)
	#incrementing per each loop
	inc = inc + 1
	
print("End of while loop")

*For loop Practice*

range_num = range(0,11,2)
for i in range_num:
	print("Range from 10: ", i)

for i in range(0,101,10):
	print("Range from 100 in multiples of 10: ", i)

print("**********")
print("End of loop")

*Prime Number Excercise*

num = int(input())

if (num < 1 or num == 1):
	print(-1)
elif (num > 1):
	for i in range(2, num):
		if (num % i == 0):
			print("False")
			break
		else:
			print("True")
			
else:
	print("True")
	

- Break will end the condition and revert to beginning of statement . Skips interation
- Continue will skip the interation if the condition is True
- Pass will ignore any errors and continue

 lis_vals=[]
 list_marks=[]}
 
 -Length property is used to dynamically check the number of elements in an array
 Keyword is len.
 - Count returns the number of occurences of an element 
 
 - Lists is a mutable data type. Able to modify, increase ,decrease etc
 
 - SLice can also be written with colon :
 
 *Slicing Excercise*
 
 #input
 num = input()
 new_list = num.split()
 
 new_num = list(map(int, new_list))
 
 first_ len(new_num) // 2
 print(new_num[:first])
 print(new_num[first:])
 
 #output
 #splut one list into 2
 
 -map() returns a map object, It takes two parameteres(var, iterable)
 
lis_nums =[1,2,3,4,5,6]

#Approach 1
#using .append
lis_sq=[]
for i in lis_nums:
	lis_sq.append(i**2)

print(list_sq)

#creates a new list and assinging the result by appending lis_nums to lis_sq

#Approach #2
#Expression apprach
lis_sq1 =[i**2 for i in lis]
print(lis_sq1)

- The above is evaulated using lis_new = [expression for i in interable]

lis_even = [i for i in lis_nums if i % 2 == 0]

'''
for i in lis_numbs:
	#if (i % 2 ==0):
		append
'''		

- Tupple unmutable array

*STRINGS*

strings are a string of characters . Example:

name = "Jason"

for i in name:
print(i, end = "--")

print(name[])

*TUPLES*
- immutable data type and always surrounded by circle brackets rather than square brackets
- Tuples only have 2 methods. Count and index
- Mainly used when data is not changed often

*EXAMPLES*

tup_new= ()
tup_nums = (1,2,3,4,5)
tup_str = ("aa", "aa", "aa", "dd", "ee")
tup_flo = (12.3,45.6,45.6)

for i in tup_str:
	print(i)
	
#first element (using both +ve and -ve index)
print(tup_flo[0])
print(tup_flo[-(len(tup_flo))])

#last element using both +ve and -ve index
print(tup_str[len(tup_str)-1])
print(tup_str[-1])

- For a single element, it will return a string or int. However if more than 1 is added, it is classified as tuple. Once a comma is detected, the type converts to tuple as it is expecting a second element. 

- Single element is treated as a Primitive type


tup_1 = (12,23,42,34,32)
print(tup_1)
print(type(tup_1))


*Tuple Packing*

- If adding different data types to a list, it is automatically packaging into a tuple regardless of circle brackets 
Example: 


data = "My", "age", 23, 34.45
print(type(data))
print(data)

*Tuple Unpackaging*
- deconstructing

a, b, c,d = data
print(a)
print(b)
print(c)
print(d)

#slicing is allowed as it does not mutate the original tuple list

tuple_nums = (1,23,4,56,54,65,79,35,46,46)
sli_tup = tuple_nums[2:5]

print(sli_tup)
print(type(tuple_nums))

num = int(input())
num2= int(input())

dic = {}
dic2 = {}

for i in range(num):
	k = input()
	v = input()
	dic.update({k:v})

for j in range(num2)
	k = input()
	v = input()
	dic2.update({k:v})

dic.update(dic2)
print(dic)

*FUNCTIONS*
- defined by keyword = def
- can be defined or predefined, predetermined . Example below;

*Function Delcartion Example*
def greet():
	print("Greet called")

*Function Invocation*
	greet()
- Parameters carry data

- Not loaded in memory until it is invoked or called

TEST

Range:
- Range has different options to be passed including the starting value, ending value, and increment
- End value is the number AFTEr the number you want to end. E.g inputting 10, counts up to 9. Ending value can also be viewed as a "less than" meaning. Meaning it will compute the number one number less than the entered number
- range (starting val, val ending before, increment). 
- If an increment is not entered, the default value of +1 is used

Libraries:
- import random and using randint (random int) creates a random generated number. Start and end para is passed ()
- Library names cannot be declared as a function or var name (similar to React). This can be fixed by first adding the keyword random in front of the library name. E.g random.randint()

Subroutine:
- Tells the computer that a piece of code exists to run multiple times
- Similar to a recipe in a cookbook. The steps are reusable and applies to the same "finished" product again and again
- Subroutine is defined by keyword "def" which is short for defintion and assigned a name , similar to a variable naming . 
- Parenths () is also needed followed by a : , regardless if an argument is passed or not. The code inside will also need to be indented
- Calling or "invoking" is also needed after the code block, similar to js. This does not to be indented
- Adding a range is also possible, amongst many other things, before calling the subroutine.
= In a subroutine, the () are for the arguments. This is also known as a parameter, which are pieces of information we pass to the code. 

Return Command:
- The return command sends some information back to the part of the code that called it. This means the function call is replaced with whatever was returned.

Scope: 
- Scope is a variable only available from inside the region it was created.
- Variables that are created for the first time in a subroutine are only available inside that subroutine.
- We cannot call the variable area outside the subroutine.
- We need to create the variable area inside the subroutine.
 
os Library:
- Libraries can be grouped by adding a , after the first library
- Time library allows to pause the execution of a program for a specific amount of time
